
    // dictionary.internal.foreach { case (key, value) =>
    //   println(key + ": " + value.toString)
    // }





// def mergeMap[A, B](ms: List[Map[A, B]])(f: (B, B) => B): Map[A, B] =
//   (Map[A, B]() /: (for (m <- ms; kv <- m) yield kv)) { (a, kv) =>
//     a + (if (a.contains(kv._1)) kv._1 -> f(a(kv._1), kv._2) else kv)
//   }
//
// val ms = List(Map("hello" -> 1.1, "world" -> 2.2), Map("goodbye" -> 3.3, "hello" -> 4.4))
// val mm = mergeMap(ms)((v1, v2) => v1 + v2)

// class NERList {
//   val internal = collection.mutable.LinkedList[(Double, NERTag.Value)]()
//   // given a double (number of chars per token), the tag B/I/O will be the prediction
//
//   def add(key: Double, tag: NERTag.Value) {
//     internal :+ (key, tag)
//   }
// }

// trait DoubleMap[A] extends MutableMap[A, Double] {
//   def add(map: Map[A, Double]) {
//     map.foreach { case (key: A, new_value: Double) =>
//       get(key) match {
//         case Some(original: Double) => update(key, original + new_value)
//         case _ => println("Default not provided, ignoring uninitialized key")
//       }
//     }
//   }
// }

// object Unoverwriteable {
//    implicit def unoverwriteableMap[A, B](map0: collection.immutable.Map[A, B]): Unoverwriteable[A, B] =
//       new Unoverwriteable[A, B] { def underlying = map0 }
//
// }

// trait IntMap[A, B] extends collection.mutable.Map[A, B] {
//   // case class KeyAlreadyExistsException(e: String) extends Exception(e)
//
//   def +=(kv: (A, B)): this.type = {
//     // if (this contains (kv _1))
//       // throw new KeyAlreadyExistsException("key already exists in WritableOnce map: %s".format((kv _1) toString))
//     super.+=(kv)
//   }
// }

// trait AddableMap[A] extends MutableMap[A, Int] {
//   def addMap(map: Map[A, Int]) {
//     map.foreach { case (key: A, value: Int) =>
//       val original_value: Int = get(key)
//       val new_value = value
//       val sum: Int = original_value + new_value
//       update(key, sum)
//     }
//   }
// }

// trait AddableMap[A, B] extends MutableMap[A, B] {
//   implicit def addMap(map: Map[A, B]) {
//     map.foreach { case (key: A, value: B) =>
//       (get(key), value) match {
//         case (Some(original_value: Int), new_value: Int) => {
//           val raw_sum: Any = original_value + new_value
//            raw_sum match {
//             case sum_value: B => update(key, sum_value)
//             case _ => println("Int + Int != Int, OMG, the world is crumbling:", raw_sum)
//           }
//         }
//         case _ => println("Default not provided, ignoring uninitialized key:", key)
//       }
//     }
//   }
// }

// object IntMap extends collection.generic.MutableMapFactory[IntMap]
  // def apply [A, B] (elems: (A, B)*): Map[A, B]

// class Tuple3(val real:Int, val imaginary:Int) {
//   def +(operand:Complex):Complex = {
//     new Complex(real + operand.real, imaginary + operand.imaginary)
//   }
// }



  // def normalizeMap(unnormalized: Map[A, Numeric]): Map[A, Double] = {
  //   val total = unnormalized.values.sum.toDouble
  //   unnormalized.map { case (key: A, value: Numeric) =>
  //     key -> value.toDouble / total
  //   }
  // }





// import scalala.tensor.dense._
// val en = DenseVector(1, 9, 7)
// val fr = DenseVector(2, -4, 2)
// en.dot(fr)
//
// en = matrix(c(1, 9, 7))
// fr = matrix(c(2, -4, 2))
// mydf = dataframe(en, fr, byrow=T)
// plot3d(en[1,], disp, mpg, col="red", size=3)
