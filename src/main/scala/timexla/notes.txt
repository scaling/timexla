  // println("transition_logprobs")
  // transition_logprobs.foreach { case (tag0, tag1_probs) =>
  //   val tag_total = tag1_probs.map(_._2).map(math.exp).sum
  //   tag1_probs.foreach { case (tag1, prob) =>
  //     println("  %s -> %s [penwidth=%1.3f];".format(tag0, tag1, 5*math.exp(prob)/tag_total))
  //   } 
  // }


  // val transitionProbabilities = (0 until numTags).map {
  //   tag => {
  //     val singleCountNextTag = transitionCounts(tag).count(x=>x._2==1)
  //     val tagLambda = lambda + singleCountNextTag
  //     val arrayOfCounts = allTagBackoff.map(_*tagLambda)
  //     transitionCounts(tag).foreach { case(nextTag, count) => arrayOfCounts(nextTag) += count }
  //     val total = arrayOfCounts.sum
  //     arrayOfCounts.map(count => math.log(count/total)).toIndexedSeq
  //   }
  // } toIndexedSeq


  // val forward_transitions = transition_counts.groupBy(_._1._1).mapValues { maps =>
  //   maps.map { case ((tag0, tag1), count) =>
  //     (tag1, count.toDouble / total_transition_counts)
  //   }
  // }
  // val backward_transitions = transition_counts.groupBy(_._1._2).mapValues { maps =>
  //   maps.map { case ((tag0, tag1), count) =>
  //     (tag0, count.toDouble / total_transition_counts)
  //   }
  // }
  // println("forward_transitions: "+forward_transitions)
  // println("backward_transitions: "+backward_transitions)
  // println("transitions: ")
  // transitions.foreach(println)
  
  // map from (unigram, tag)-tuples to probabilities (doubles)

  // val total_dictionary = dictionary_counts.internal.values.foldLeft(0)((accumulator, tuple) => tuple._1 + tuple._2 + tuple._3)





  // unigram_counts.internal = 
  // Map[unigram: String -> counts: Array[Int]] # one value in the array for each of B, I, and O
  // unigrams = List[(unigram, BIOTag) -> probability: Double]

  // val smoothedWordCounts = wordSequence.groupBy(x=>x).mapValues(_.length + 1)


    //   (unigram, tag) -> (math.log(array() - logsum))
    // emission_counts(
    // val logsum = math.log(array.sum.toDouble)
    // println("%14s: %2d %1d %3d = %4d" format (unigram, array(0), array(1), array(2), array.sum))
  // }

  // DEBUG
  // unigram_probs.map { case (token, prob) =>
  //   val tagprobs = BIOTag.values.map { tag =>
  //     val eprob = emission_logprobs(tag)(token)
  //     "%s: %3.4f" format (tag, eprob)
  //   }.mkString("  ")
  //   println("%16s = %s (%3.4f)" format (token, tagprobs, math.log(prob)))
  // }
    
  // emission_logprobs.flatMap { case (tag, token_probs) =>
  //   token_probs.map { case (token, prob) => (token, tag, prob) }
  // }.groupBy(_._1).mapValues { list =>
  //   list.map { case (token, tag, prob) =>
  //     "%s: %3.4f" format (tag, prob)
  //   }
  //   BIOMap.values.map { tag =>
  //     
  //   }.mkString("  ")
  // }.foreach { case (token, str) =>
  //   println("%16s = %s" format (token, str))
  // }
    
  // println()
    
  // unigram_logprobs.groupBy(
  // val smoothed_unigram_logprobs = 

  // val unigram_bio_logprobs = unigram_bio_counts.internal.flatMap { case (unigram, array) =>
  //   val logsum = math.log(array.sum.toDouble)
  //   // println("%14s: %2d %1d %3d = %4d" format (unigram, array(0), array(1), array(2), array.sum))
  //   BIOTag.values.map(tag => (unigram, tag) -> (math.log(array(tag.id)) - logsum))
  // }
  
  // { // debug ###################
    // unigram_bio_logprobs.toList.sorted.foreach { case (key, value) =>
    //   println("%4s: %.7f" format (key, value))
    // }
  // } // #########################








    // (1 to 3).foreach { i =>
    //   println("alpha.length - " + i + " " + alpha(alpha.length - i).map(state =>
    //     "%s^%3.4f".format(state.tag, state.logprob)).mkString("   "))
    //   val max = alpha(alpha.length - i).max
    //   println("max " + max.tag + " " + max.logprob)
    // }
    // println("alpha_max_sequence.length: "+alpha_max_sequence.length)
    // println("tokens.length: "+tokens.length)
    // , alpha_max_sequence.map(_.tag), tokens.drop(1))

    // println("alpha last: "+alpha.last.map(_.probability).mkString(" "))
    
    // Array[MapLike[BIOTag.Value, State]]() :+ BIOTag.values.map(tag => tag -> State(1d/3, tag, None)).toMap
    // val beta = Array.fill(tokens.length, BIOTag.values.size)(State.Empty)
    // BIOTag.values.foreach { tag => beta(beta.length - 1)(tag.id) = State(1d/3, tag, None) }
    // (1 until (tokens.length - 1)).reverse.foreach { i =>
    //   BIOTag.values.foreach { tag =>
    //     val inbound_probabilities = BIOTag.values.map { next_tag => 
    //       (beta(i + 1)(next_tag.id).probability + transition_logprobs((tag, next_tag)), next_tag)
    //     }
    //     val inbound_sum = inbound_probabilities.map(_._1).sum
    //     val inherent_prob = unigrams((tokens(i), tag)) // this will be extended with the other features
    //     val next_state = Some(beta(i + 1)(inbound_probabilities.max._2.id))
    //     beta(i)(tag.id) = State(inbound_sum*inherent_prob, tag, next_state)
    //   }
    // }
    // println("Raw lengths: "+alpha.length+" "+beta.length+".")

    // finish up ??
        
    // pertinent folding:
    // val ones = List(1, 1, 1, 1, 1, 1, 1, 1)
    // ones.foldLeft(List(0))((accumulator, value) => accumulator :+ accumulator.last + value).tail
    
    // val states = ListBuffer[State](alpha.last.values.max)
    
    // def maximize_sequence(seq: List[Array[State]]) = {
    //   val states = ListBuffer[State]()
    //   while (true) {
    //     states.last.previous match {
    //       case Some(state) => {
    //         states += state
    //       }
    //       case _ => break
    //     }
    //   }
    //   states.reverse
    //   // (1 until seq.length).foldLeft()((accumulator, column) =>
    //   //   accumulator.last.previous_state match {
    //   //     case Some(state) => accumulator :+ state
    //   //     case _ => accumulator
    //   //   }
    //   // ).reverse
    // }
    // println("alpha_max_sequence")
    // println(alpha_max_sequence.map(state => state.tag+" "+state.logprob).mkString("\n"))
    // val beta_max_sequence = maximize_sequence(beta.toList.drop(1).reverse).reverse
    // (1 until alpha.length).foreach { i =>
    //   states.last.previous_state match {
    //     case Some(state: State) => states += state
    //     case _ =>
    //   }
    // }
    // val states = alpha.foldLeft(List(alpha.last.values.max))((accumulator, value) => 
      // accumulator :+ accumulator.last.previous_state)
    // alpha_max_sequence.foreach(state => println(state.tag + " : " + state.probability))
    
    // .map { case (alpha, i) =>  alpha  (tokens.length).map
    
    // println("Lengths: "+alpha_max_sequence.length+" "+beta_max_sequence.length+" "+tokens.length)